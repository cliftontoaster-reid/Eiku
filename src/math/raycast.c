/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycast.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: autogenerated                                +#+  +:+       +#+ */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/03 00:00:00 by tool                #+#    #+# */
/*   Updated: 2025/10/03 00:00:00 by tool               ###   ########.fr */
/*                                                                            */
/* ************************************************************************** */

#include "math/raycast.h"

#include <math.h>

int eiku_raycast_cast(const t_eiku_2dscene *scene, t_vec2f origin, t_vec2f dir,
                      t_eiku_raycast_hit *out) {
  if (!scene || !scene->map_data || !out) return 0;

  int map_x = (int)floorf(origin.x);
  int map_y = (int)floorf(origin.y);

  /* Direction components */
  float ray_dir_x = dir.x;
  float ray_dir_y = dir.y;

  /* Length of ray from one x or y-side to next x or y-side */
  float delta_dist_x = (ray_dir_x == 0.0f) ? 1e30f : fabsf(1.0f / ray_dir_x);
  float delta_dist_y = (ray_dir_y == 0.0f) ? 1e30f : fabsf(1.0f / ray_dir_y);

  int step_x;
  int step_y;
  float side_dist_x;
  float side_dist_y;

  /* Calculate step and initial sideDist */
  if (ray_dir_x < 0) {
    step_x = -1;
    side_dist_x = (origin.x - (float)map_x) * delta_dist_x;
  } else {
    step_x = 1;
    side_dist_x = ((float)(map_x + 1) - origin.x) * delta_dist_x;
  }
  if (ray_dir_y < 0) {
    step_y = -1;
    side_dist_y = (origin.y - (float)map_y) * delta_dist_y;
  } else {
    step_y = 1;
    side_dist_y = ((float)(map_y + 1) - origin.y) * delta_dist_y;
  }

  /* DDA loop */
  int hit = 0;
  int side = 0; /* 0 for x, 1 for y */
  int max_x = scene->map_size.x;
  int max_y = scene->map_size.y;

  while (!hit) {
    /* jump to next map square, OR in x-direction, OR in y-direction */
    if (side_dist_x < side_dist_y) {
      side_dist_x += delta_dist_x;
      map_x += step_x;
      side = 0;
    } else {
      side_dist_y += delta_dist_y;
      map_y += step_y;
      side = 1;
    }

    /* Check if ray is outside map bounds */
    if (map_x < 0 || map_x >= max_x || map_y < 0 || map_y >= max_y)
      return 0; /* miss */

    /* Non-zero map cell indicates wall */
    if (scene->map_data[map_y][map_x]) hit = 1;
  }

  /* Calculate perpendicular distance to avoid fisheye */
  float perp_dist;
  if (side == 0) {
    perp_dist = (map_x - origin.x + (1 - step_x) / 2.0f) / ray_dir_x;
  } else {
    perp_dist = (map_y - origin.y + (1 - step_y) / 2.0f) / ray_dir_y;
  }

  /* hit position on the wall (0..1) */
  float hit_x;
  if (side == 0)
    hit_x = origin.y + perp_dist * ray_dir_y;
  else
    hit_x = origin.x + perp_dist * ray_dir_x;
  hit_x -= floorf(hit_x);

  out->map_x = map_x;
  out->map_y = map_y;
  out->side = side;
  /* Determine cardinal face based on which side was hit and the ray step */
  if (side == 0) {
    /* vertical wall (x-side): if step_x > 0 we hit the west face of the new
     * cell (because we moved +x into it), else east face of the new cell. Here
     * we pick EAST/WEST consistent with map axes: stepping +x means we crossed
     * the west edge of the target cell (so face is WEST). To avoid confusion,
     * we define: when moving +x the face seen is WEST (the face at smaller x of
     * the cell we entered). */
    if (step_x > 0)
      out->face = EIKU_RAY_FACE_WEST;
    else
      out->face = EIKU_RAY_FACE_EAST;
  } else {
    /* horizontal wall (y-side) */
    if (step_y > 0)
      out->face = EIKU_RAY_FACE_NORTH;
    else
      out->face = EIKU_RAY_FACE_SOUTH;
  }
  out->perp_dist = perp_dist;
  out->hit_x = hit_x;

  return 1;
}
